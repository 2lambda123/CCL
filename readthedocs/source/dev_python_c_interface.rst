.. _pycint:

******************
Python-C Interface
******************

The ``Python`` interface to the CCL ``C`` code is built using ``SWIG``,
which automatically scans the CCL ``C`` headers and builds a matching
interface in ``Python``. The autogenerated ``SWIG`` interface can be accessed
through the ``pyccl.ccllib`` module. The actual CCL API in ``Python`` is a more
user-friendly wrapper that has been written on top of the ``SWIG``-generated
code.


Key Parts of SWIG Wrapper
=========================

The key parts/conventions of the ``SWIG`` wrapper are as follows:

- Interface ``.i`` files: These are kept in the ``pyccl/`` directory, and tell
  ``SWIG`` which functions to extract from the ``C`` headers. There are also
  commands in these files to generate basic function argument documentation,
  and to remove the ``ccl_`` prefix from function names. The interface files
  also contain code that tells ``SWIG`` how to convert ``C`` array arguments to
  ``numpy`` arrays. For certain functions, this code may also contain a simple
  loop to vectorize the function.

- Main interface file ``pyccl/ccl.i``: This file imports all of the other
  interface files. Most of the ``CCL`` source files (e.g. ``ccl_core.c``) have
  their own interface file too. For other files, mostly containing
  support/utility functions, ``SWIG`` only needs the ``C`` header (``.h``) file
  to be specified in the main ``ccl.i`` file.

- Internal CCL C-level global state: All global state in the ``CCL`` library
  (e.g., whether or not the power spectra splines are initialized and calling
  the function to initialize them) is controlled by the ``Python`` code. This
  convention ensures that when the ``C`` code is running, all data needed
  already exists. It also allows us to more easily use ``OpenMP`` in the ``C``
  layer, avoiding the problem of having to manage the global state from more
  than one thread. In practice, this means that before you call the ``CCL``
  ``C`` library from ``Python``, you need to check to make sure that any
  internal ``C`` data you need has been initialized. The ``pyccl.Cosmology``
  object has methods to help with this (e.g., ``compute_distances()``).

The ``SWIG`` interface files may also include:

- Declarations of inline ``C`` code to enable fast, vectorized computations.

- Use of ``numpy.i`` type signatures, described in the `Numpy documentation
  <https://docs.scipy.org/doc/numpy/reference/swig.interface-file.html>`_
  to enable vectorized inputs and outputs. The ``pyccl/ccl.i`` interface file
  defines a global ``numpy`` type signature for the ``status`` variable.

- Use of the ``SWIG`` ``pythonprepend`` feature to check the I/O sizes and
  ensure we do not access out-of-bounds memory.


Error Handling
==============

Errors in CCL happen both in the ``C`` and ``Python`` code. Error handling in
the ``C`` code is subtle because the ``C`` code cannot (currently) raise
``Python`` exceptions directly.

Instead, CCL takes the convention that each ``C`` function passes back or
returns a ``status`` value. Non-zero values indicate an error. Further, certain
values have special meanings that are defined in the `include/ccl_error.h
<https://github.com/LSSTDESC/CCL/blob/master/include/ccl_error.h>`_ header.

In the ``C`` layer, functions can write information about errors into a string
held by the ``C``-level of the ``cosmo`` struct. The ``Python`` layer reads the
value of this string and raises it with a ``Python`` error when a non-zero
status is returned.

Using these two mechanisms, ``Python`` functions in the CCL ``Python`` API can
check for errors in the ``C`` layer and report back useful information to the
user.
